// Generated by CoffeeScript 1.10.0
(function() {
  var all, commands, dynamic, everySecond, evil, exceptFirst, exceptLast, first, keys, migrate, multi, prefixKeys, prefixer, proxies, sort,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  commands = require('redis-commands').list;

  first = {
    proxy: function(command, prefix, db) {
      return function() {
        var args, key;
        key = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        return db[command].apply(db, [prefix + key].concat(slice.call(args)));
      };
    },
    commands: ['append', 'decr', 'decrby', 'dump', 'exists', 'expire', 'expireat', 'get', 'getbit', 'getrange', 'getset', 'hdel', 'hexists', 'hget', 'hgetall', 'hincrby', 'hincrbyfloat', 'hkeys', 'hlen', 'hmget', 'hmset', 'hset', 'hsetnx', 'hvals', 'incr', 'incrby', 'incrbyfloat', 'lindex', 'linsert', 'llen', 'lpop', 'lpush', 'lpushx', 'lrange', 'lrem', 'lset', 'ltrim', 'move', 'persist', 'pexpire', 'pexpireat', 'psetex', 'pttl', 'publish', 'restore', 'rpop', 'rpush', 'rpushx', 'sadd', 'scard', 'set', 'setbit', 'setex', 'setnx', 'setrange', 'sismember', 'smembers', 'spop', 'srandmember', 'srem', 'strlen', 'ttl', 'type', 'zadd', 'zcard', 'zcount', 'zincrby', 'zrange', 'zrangebyscore', 'zrank', 'zrem', 'zremrangebyrank', 'zremrangebyscore', 'zrevrange', 'zrevrangebyscore', 'zrevrank', 'zscore']
  };

  all = {
    proxy: function(command, prefix, db) {
      return function() {
        var keys, prefixed;
        keys = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        prefixed = prefixKeys(prefix, keys);
        return db[command].apply(db, prefixed);
      };
    },
    commands: ['del', 'psubscribe', 'punsubscribe', 'subscribe', 'unsubscribe', 'watch', 'rpoplpush', 'mget', 'rename', 'renamenx', 'sdiff', 'sdiffstore', 'sinter', 'sinterstore', 'sunion', 'sunionstore']
  };

  exceptFirst = {
    proxy: function(command, prefix, db) {
      return function() {
        var arg, keys, prefixed;
        arg = arguments[0], keys = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        prefixed = prefixKeys(prefix, keys);
        return db[command].apply(db, [arg].concat(slice.call(prefixed)));
      };
    },
    commands: ['bitop']
  };

  exceptLast = {
    proxy: function(command, prefix, db) {
      return function() {
        var arg, cb, i, keys, prefixed;
        keys = 3 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 2) : (i = 0, []), arg = arguments[i++], cb = arguments[i++];
        if (typeof cb === 'function') {
          prefixed = prefixKeys(prefix, keys);
          return db[command].apply(db, slice.call(prefixed).concat([arg], [cb]));
        } else {
          keys.push(arg);
          arg = cb;
          prefixed = prefixKeys(prefix, keys);
          return db[command].apply(db, slice.call(prefixed).concat([arg]));
        }
      };
    },
    commands: ['blpop', 'brpop', 'brpoplpush', 'smove']
  };

  everySecond = {
    proxy: function(command, prefix, db) {
      return function() {
        var arg, args, i, index, len, prefixed;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        prefixed = [];
        for (index = i = 0, len = args.length; i < len; index = ++i) {
          arg = args[index];
          if (index % 2 || index === args.length - 1) {
            prefixed.push(arg);
          } else {
            prefixed.push(prefix + arg);
          }
        }
        return db[command].apply(db, prefixed);
      };
    },
    commands: ['mset', 'msetnx']
  };

  migrate = {
    proxy: function(command, prefix, db) {
      return function(host, port, key, dest, timeout, next) {
        return db[command](host, port, prefix + key, dest, timeout, next);
      };
    },
    commands: ['migrate']
  };

  dynamic = {
    proxy: function(command, prefix, db) {
      return function() {
        var args, dest, keys, numKeys, prefixed;
        dest = arguments[0], numKeys = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
        keys = args.splice(0, numKeys);
        prefixed = prefixKeys(prefix, keys);
        return db[command].apply(db, [prefix + dest, numKeys].concat(slice.call(prefixed), slice.call(args)));
      };
    },
    commands: ['zinterstore', 'zunionstore']
  };

  evil = {
    proxy: function(command, prefix, db) {
      return function() {
        var args, keys, numKeys, prefixed, script;
        script = arguments[0], numKeys = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
        keys = args.splice(0, numKeys);
        prefixed = prefixKeys(prefix, keys);
        return db[command].apply(db, [script, numKeys].concat(slice.call(prefixed), slice.call(args)));
      };
    },
    commands: ['eval']
  };

  sort = {
    proxy: function(command, prefix, db) {
      return function() {
        var arg, args, i, key, lastArg, len, prefixed;
        key = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        prefixed = [];
        lastArg = '';
        for (i = 0, len = args.length; i < len; i++) {
          arg = args[i];
          if (lastArg.toLowerCase() === 'get') {
            prefixed.push(prefix + arg);
          } else {
            prefixed.push(arg);
          }
          lastArg = arg;
        }
        return db[command].apply(db, [prefix + key].concat(slice.call(prefixed)));
      };
    },
    commands: ['sort']
  };

  keys = {
    proxy: function(command, prefix, db) {
      return function(pattern, next) {
        if (!next) {
          return;
        }
        return db[command](prefix + pattern, function(err, result) {
          var k;
          if (err) {
            return next(err);
          }
          return next(null, (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = result.length; i < len; i++) {
              k = result[i];
              results.push(k.substring(prefix.length));
            }
            return results;
          })());
        });
      };
    },
    commands: ['keys']
  };

  multi = {
    proxy: function(command, prefix, db) {
      return function() {
        return prefixer(db.multi(), true)(prefix);
      };
    },
    commands: ['multi']
  };

  proxies = [first, all, exceptFirst, exceptLast, everySecond, migrate, dynamic, evil, sort, keys, multi];

  prefixKeys = function(prefix, keys) {
    var key, prefixed;
    return prefixed = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        if (typeof key === 'function') {
          results.push(key);
        } else {
          results.push(prefix + key);
        }
      }
      return results;
    })();
  };

  module.exports = prefixer = function(db, chain) {
    return function(prefix) {
      var command, i, j, len, len1, p, proxy, proxyCommand;
      proxy = {};
      proxyCommand = function(command) {
        return proxy[command] = function() {
          return db[command].apply(db, arguments);
        };
      };
      for (i = 0, len = commands.length; i < len; i++) {
        command = commands[i];
        for (j = 0, len1 = proxies.length; j < len1; j++) {
          p = proxies[j];
          if (indexOf.call(p.commands, command) >= 0) {
            (function(command) {
              var c;
              c = p.proxy(command, prefix, db);
              return proxy[command] = function() {
                var r;
                r = c.apply(db, arguments);
                if (chain) {
                  return proxy;
                } else {
                  return r;
                }
              };
            })(command);
          }
        }
        if (!(command in proxy)) {
          proxyCommand(command);
        }
      }
      return proxy;
    };
  };

}).call(this);
